## 设计模式

### 六大原则
1、单一原则：一个类应该只有一个引起变化的原因，一个类或者模块应该专注单一功能。这样的好处，类复杂性降低，可读性高，易维护。

2、开放封闭原则：对扩展是开放的，但对修改是封闭的。系统设计允许在不修改现有代码的情况下进行扩展，通过添加新的功能。

3、里氏替换原则：任何基类可以出现的地方，子类一定可以出现，而且需要替换基类并不会产生任何不良行为。子类应该能够替换其父类并保持系统行为的一致性。

>子类必须完全实现父类的方法。也就是说，子类中不能缺少父类中已经声明过的方法，也不能改变父类中方法的行为（如参数列表、返回类型等）。
>
>父类中的所有公开引用都应使用父类或者接口来进行定义。这样做的好处是可以避免耦合度过高，并且可以使代码更加模块化。
>
>在不违反封装的原则下，尽量减少子类对父类内部状态的依赖。这样做可以让子类具有更好的可扩展性和可维护性。 总的来说，里氏替换原则旨在确保当一个类被其子类替换时，不会影响整个程序的正确性。遵守这一原则可以帮助我们创建出更稳定、更灵活的软件系统。

4、依赖倒置原则：高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。（说白了就是面向接口编程）

5、接口隔离原则：不应该强迫客户端依赖于它们不使用的接口。应该将接口设计得精细小巧，尽量避免庞大臃肿的接口。

6、迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。优先使用对象组合，而不是继承来实现代码的复用。通过组合（组合多个类的功能）来达到代码复用，而不是通过继承来获得现有类的功能。

### 创建者模式

> creator 模块

创建者模式是一种常见的设计模式，它可以分为以下几种：

+ 单例模式：这种模式只有一个实例，并且提供了一种全局访问点。
+ 工厂模式：这种模式可以根据传入的参数动态地创建对象。
+ 抽象工厂模式：这种模式允许创建一系列相关或相互依赖的对象，而不指定其具体的实现细节。
+ 建造者模式：这种模式将复杂的对象构建过程分解为多个独立的步骤。
+ 原型模式：这种模式可以复制现有对象，而不是创建新对象。

#### 工厂模式

工厂模式的核心思想是将对象的创建和使用分离出来，使得用户只需要关心对象的使用，而不需要关注对象的具体实现。具体来说，工厂模式提供了一个统一的接口，用户通过调用工厂方法来获取所需对象，而不需要关心对象是如何被创建的。
工厂模式的优点如下：

  * 用户只需关注对象的使用，不需要关心对象的创建过程。
  * 对象的创建过程由工厂负责，因此可以在运行时决定要创建哪个具体对象，这样就可以动态地更改对象的创建方式。
  * 如果有很多相似的对象需要创建，工厂模式可以简化代码，使得代码易于理解和维护。

工厂模式的缺点如下：

  * 如果对象有很多不同的创建方式，那么就需要很多工厂方法，这会使代码变得复杂。
  * 如果没有适当地封装工厂方法，那么就会使代码难以维护和扩展。
  * 如果新的产品对象不断添加进来，那么可能需要不断地修改工厂方法，这会破坏软件的设计灵活性。
  
#### 单例模式

单例模式的核心思想是保证一个类只产生一个实例，并且提供一个全局访问点来获取这个实例。具体来说，单例模式会限制类的构造函数对外部的可见性，并提供一个静态方法来获取唯一的实例。
单例模式的优点如下：

  * 控制了类的实例数量，节约了系统资源。
  * 具备一定的灵活性，在需要的时候可以动态地创建实例。
  * 单例类可以拥有私有的属性，这样就可以防止外部直接修改实例的状态。

单例模式的缺点如下：

  * 类的生命周期无法控制，因为单例对象一旦创建就会一直存在，直到 JVM 结束运行。
  * 如果有多个线程并发地请求单例对象，那么可能会出现多个实例的情况，因此需要采取一些措施来保证单例的线程安全性。
  * 不利于测试，因为单例对象在每次测试中只能有一个，不利于模拟多实例的情况。
  
  
#### 抽象工厂模式

抽象工厂模式的核心思想是提供一个接口来创建一组相关或相互依赖的对象，而无需关心具体的产品及其细节。具体来说，它可以创建一系列的产品家族，每个产品家族包含了一系列相关的对象，而不需要知道它们的具体实现。
抽象工厂的优点如下：

  * 提供了一个简单的方式来创建一系列相关或相互依赖的对象。
  * 可以在运行时改变产品家族的内容，例如，你可以很容易地替换掉某个产品家族中的产品。
  * 降低了客户端代码与产品家族之间的耦合度，提高了代码的可扩展性和可维护性。

抽象工厂的缺点如下：

  * 当产品家族的数量增多时，需要创建更多的工厂类，这可能导致代码量增大。
  * 如果要改变产品家族的内容，则需要更新很多地方的代码。

总之，抽象工厂模式可以方便地组织相关的产品家族，并且可以在运行时更改产品的实现。但是，随着产品家族数量的增长，可能会导致代码量增大。

